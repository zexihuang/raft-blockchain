Done:
1) Leader's previous log is to be overwritten after steps downs.
2) Transfer transaction test
5) Commit watch with several blocks commited at the same time, without ordering requirement.
TODO:
6) When nobody is the leader and the client sends a request.
   Note: There is no problem for this case. The default server will wait until a leader is elected and then relayed.
   Note: However, if at that time, the default server itself is elected as an leader, he will "relay" it to itself, which may not work if he's partitioned out.
   But that should not affect too much since the client will resend and he will receive as leader.
3) Persistent states.
   -> Save after every vote/operation/client receive is done
   -> Crash during acquire, will lock we released, we need to check this...
7) a) BUG: after a leader sets receive the accept message from a majority and sets its own commit index to 5,
   it dies immediately before sending out an append request with a new commit index. Therefore, none of its follower has
   updated their commit index to 5, let's say they are still 3. Then, one of the followers becomes the new leader, and the
   old leader joins back as the follower.
   b) FIXED by comparing current commit index with the message commit index before committing as a follower.
4) Reading first blockchain file, and populate blockchain with that.
    -> Channel reads blockchain.txt and turned into blockchain_processed.pkl, then servers are reading that pkl file to make sure
    their blockchains are same.
    -> We need to initialize some variable like commit_index etc based on blockchain.
